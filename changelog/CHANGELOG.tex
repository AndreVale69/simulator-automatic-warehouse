\documentclass[a4paper]{article}
\usepackage[italian]{babel}
\usepackage[italian]{isodate}  		% formato delle date in italiano
\usepackage{enumitem}				% gestione delle liste
\usepackage{pifont}					% pacchetto con elenchi carini
\usepackage[x11names]{xcolor}		% colori aggiuntivi
% Link ipertestuali per l'indice
%\usepackage{xcolor}
\usepackage[linkcolor=black, citecolor=blue, urlcolor=cyan]{hyperref}
\hypersetup{
	colorlinks=true
}

\newcommand{\dquotes}[1]{``#1''}

\begin{document}
	\title{Changelog}
	\date{\today}
	\maketitle
	
	\newpage
	
	\section*{Main Improvements}
	
	\begin{itemize}[label=\ding{51}]
		\item I valori del \textsf{JSON} vengono letti all'interno del costruttore. La funzione legge il file e restituisce il relativo dizionario. Nel costrutto si provvede a caricare tutti i valori nei specifici campi.
		
		\item Rimossi tutti i \textsf{super()} dove era possibile (nei costrutti \textsf{\_\_init\_\_} era impossibile toglierlo).
		
		\item Modificate alcuni nomi delle variabili per essere conformi ai nomi nel \textsf{JSON}.
		
		\item All'interno del costrutto della classe \textsf{Warehouse} avviene la costruzione delle colonne e del carosello passando ai costrutti le varie informazioni.
		
		\item Rimosso il campo del numero delle entries, adesso ogni figlio crea il suo array di oggetti senza utilizzare la superclasse.
		
		\item \textsf{Deepcopy} implementata, ma perché era necessario copiare di nuovo i valori appena passati all'oggetto? Prendi come esempio la classe \textsf{Material} che è semplice.
		
		\item Ogni \textsf{Drawer} ha un campo nella classe che lo collega con la prima \emph{entry} all'interno del \emph{container} delle \emph{entries}.
	\end{itemize}
\end{document}